using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using System.IO;
using System.Diagnostics;
using System.Threading;

namespace NifPatcher {
    public class Program {

        static Lazy<Settings> _Settings = null!;
        public static Settings Settings => _Settings.Value;
        public static async Task<int> Main(string[] args) {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences() {
                    NoPatch = true
                })
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "YourPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            var stopwatch = Stopwatch.StartNew();
            var ruleFiles = Directory.GetFiles(Settings.ruleDirectory, "*.txt", SearchOption.AllDirectories);
            foreach(var ruleFile in ruleFiles) {
                var lines = File.ReadAllLines(ruleFile);
                try {
                    RuleParser.ParseRuleBlock(lines);
                } catch(RuleParser.RuleParseException e) {
                    throw new Exception("Cannot parse line in file " + ruleFile + " at line " + e.line + ": " + lines[e.line] + "\n" + "Message:\n" + e.Message);
                }
            }
            Console.WriteLine();

            var inFiles = Directory.GetFiles(Settings.inPath, "*.nif", SearchOption.AllDirectories);

            int progressCounter = 0;
            Parallel.For(0, inFiles.Length, new ParallelOptions() {
                MaxDegreeOfParallelism = 8,
            }, (i) => {
                var inFile = inFiles[i];
                var relativePath = Path.GetRelativePath(Settings.inPath, inFile);
                var progress = "" + (i + 1) + "/" + inFiles.Length + ": ";
                var nif = new NifFileWrapper(inFile);
                if(RuleParser.PatchNif(nif)) {
                    var outPath = Path.Combine(Settings.outPath, relativePath);
                    Directory.CreateDirectory(Directory.GetParent(outPath)!.FullName);
                    nif.SaveAs(outPath);
                    Console.WriteLine(Interlocked.Increment(ref progressCounter) + "/" + inFiles.Length + " " + relativePath + " saved");
                } else {
                    Console.WriteLine(Interlocked.Increment(ref progressCounter) + "/" + inFiles.Length + " " + relativePath + " no changed");
                }
            });
            stopwatch.Stop();
            Console.WriteLine(stopwatch.ElapsedMilliseconds + "ms");
        }
    }
}
